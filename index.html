<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WordCraft 3D: Ultimate Edition</title>
    <style>
        /* --- 1. SHARED STYLES --- */
        body { margin: 0; overflow: hidden; font-family: 'Verdana', sans-serif; user-select: none; }
        
        /* --- 2. DESKTOP HUD --- */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            border: 2px solid rgba(255,255,255,0.8); border-radius: 50%; 
            transform: translate(-50%, -50%); pointer-events: none; mix-blend-mode: difference; z-index: 10;
            display: none;
        }
        #hud-desktop {
            position: absolute; top: 10px; left: 10px; color: white; 
            text-shadow: 2px 2px 0 #000; pointer-events: none; display: none; z-index: 10;
        }
        
        /* --- 3. THE "ORIGINAL" 2D INVENTORY (Restored!) --- */
        #desktop-inv {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 700px; height: 500px; background-color: #f3e5f5; 
            border: 4px solid #5d4037; border-radius: 8px; display: none; 
            flex-direction: column; z-index: 100; color: #3e2723;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        
        .inv-header { padding: 15px; background: rgba(255,255,255,0.95); border-bottom: 3px solid #5d4037; }
        .inv-body { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 15px; }
        
        /* The Forge Area */
        .crafting-grid { display: flex; justify-content: center; align-items: center; gap: 10px; padding: 20px; background: rgba(0,0,0,0.05); border-radius: 8px; }
        .craft-slot { 
            width: 80px; height: 80px; border: 3px dashed #5d4037; display: flex; 
            align-items: center; justify-content: center; font-weight: bold; 
            background: #fff; cursor: pointer; border-radius: 8px; font-size: 14px;
            transition: 0.2s;
        }
        .craft-slot:hover { border-color: #e67e22; transform: scale(1.05); }
        
        /* Chips */
        .inv-grid { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; padding: 10px; background: rgba(255,255,255,0.5); border-radius: 8px; min-height: 100px; }
        .word-chip { 
            background: #fff; border: 2px solid #5d4037; padding: 8px 15px; border-radius: 20px; 
            cursor: pointer; font-size: 14px; font-weight: bold; box-shadow: 0 3px 0 rgba(0,0,0,0.2); 
        }
        .word-chip:active { transform: translateY(2px); box-shadow: none; }
        .chip-pre { background-color: #bbdefb; border-color: #1565c0; color: #0d47a1; } 
        .chip-root { background-color: #c8e6c9; border-color: #2e7d32; color: #1b5e20; }
        .chip-suf { background-color: #e1bee7; border-color: #7b1fa2; color: #4a148c; } 

        #forge-msg { 
            min-height: 60px; background: #fff8e1; border: 2px solid #d35400; 
            margin-top: 10px; padding: 10px; text-align: center; border-radius: 6px; 
            color: #d35400; font-weight: bold; display: flex; align-items: center; justify-content: center;
        }
        
        .close-btn { 
            margin: 15px; padding: 10px; background: #c0392b; color: white; 
            border: none; font-weight: bold; border-radius: 5px; cursor: pointer; 
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="crosshair"></div>
    <div id="hud-desktop">
        <h2>WordCraft 3D</h2>
        <p>Click to Capture Mouse | 'E' for Inventory</p>
        <p>Gems: <span id="hud-gems">0</span></p>
    </div>

    <div id="desktop-inv">
        <div class="inv-header">
            <h2 style="margin:0; text-align:center; color:#5d4037;">The Word Forge</h2>
        </div>
        <div class="inv-body">
            <div class="crafting-grid">
                <div id="slot-pre" class="craft-slot" onclick="clearSlot('pre')">[Pre]</div> +
                <div id="slot-root" class="craft-slot" onclick="clearSlot('root')">[ROOT]</div> +
                <div id="slot-suf" class="craft-slot" onclick="clearSlot('suf')">[Suf]</div>
                <button onclick="runForge()" style="height:80px; width:80px; background:#27ae60; border:none; color:white; border-radius:8px; font-weight:bold; cursor:pointer; margin-left:15px; font-size:30px;">üî®</button>
            </div>
            <div id="forge-msg">Construct a word to check the Dictionary!</div>
            
            <div style="display:flex; gap:10px; margin-top:10px;">
                <div style="flex:1;">
                    <small style="background:#a1887f; color:white; padding:4px 8px; border-radius:4px; font-weight:bold;">ROOTS</small>
                    <div id="list-roots" class="inv-grid"></div>
                </div>
                <div style="flex:1;">
                    <small style="background:#90caf9; color:#0d47a1; padding:4px 8px; border-radius:4px; font-weight:bold;">AFFIXES</small>
                    <div id="list-affixes" class="inv-grid"></div>
                </div>
            </div>
        </div>
        <button class="close-btn" onclick="toggleInventory()">Close (Resume Game)</button>
    </div>

<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

    // --- 1. DATA & STATE ---
    const WORD_DATA = {
        "dirt": { roots: ["play", "help", "walk"], affixes: ["s", "ed", "ing"] },
        "stone": { roots: ["struct", "ject", "form"], affixes: ["re", "un", "tion"] },
        "wood": { roots: ["grow", "leaf"], affixes: ["ness", "ful"] }
    };
    
    let player = { gems: 0, roots: [], affixes: [] };
    let forge = { pre: null, root: null, suf: null };

    // --- 2. SCENE ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 20, 60);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    const user = new THREE.Group();
    user.position.set(0, 10, 0); // Start high to fall
    user.add(camera);
    scene.add(user);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);
    document.body.appendChild(VRButton.createButton(renderer));

    // Lights
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
    scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(50, 100, 50);
    scene.add(dirLight);

    // --- 3. BLOCK ENGINE (With Collision) ---
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    
    // Better Materials (With Outlines)
    const textureLoader = new THREE.TextureLoader();
    // We create a "Border" texture programmatically so we don't need external files
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,64,64); // White Base
    ctx.strokeStyle = '#cccccc'; ctx.lineWidth = 4; ctx.strokeRect(0,0,64,64); // Border
    const borderTex = new THREE.CanvasTexture(canvas);
    borderTex.magFilter = THREE.NearestFilter;

    function makeMat(color) {
        return new THREE.MeshLambertMaterial({ color: color, map: borderTex });
    }

    const materials = {
        grass: makeMat(0x2ecc71), dirt: makeMat(0x5d4037),
        stone: makeMat(0x7f8c8d), wood: makeMat(0x8d6e63), leaf: makeMat(0x27ae60)
    };

    const chunks = {};
    const collisionBlocks = []; // For Physics
    const visualBlocks = []; // For Raycasting

    function getChunkKey(x, z) { return `${Math.floor(x/16)},${Math.floor(z/16)}`; }

    function createBlock(x, y, z, type) {
        const mesh = new THREE.Mesh(geometry, materials[type]);
        mesh.position.set(x, y, z);
        mesh.userData = { type: type, isBlock: true };
        scene.add(mesh);
        collisionBlocks.push(mesh); // Add to physics world
        visualBlocks.push(mesh);
        return mesh;
    }

    function generateWorld() {
        // Generate a 20x20 area around 0,0
        for(let x=-10; x<10; x++) {
            for(let z=-10; z<10; z++) {
                let h = Math.floor(Math.sin(x*0.2)*2 + Math.cos(z*0.2)*2);
                createBlock(x, h, z, 'grass');
                // Fill UNDER the surface so we can dig
                for(let d=1; d<5; d++) createBlock(x, h-d, z, 'dirt');
                for(let d=5; d<10; d++) createBlock(x, h-d, z, 'stone');
            }
        }
    }
    generateWorld();

    // --- 4. PHYSICS (Collision Detection) ---
    const playerVelocity = new THREE.Vector3();
    const playerDirection = new THREE.Vector3();
    const box = new THREE.Box3();
    const playerBox = new THREE.Box3();
    const playerSize = new THREE.Vector3(0.6, 1.8, 0.6); // Player Hitbox

    function checkCollision(pos) {
        // Create player bounding box at position
        playerBox.setFromCenterAndSize(pos, playerSize);
        
        // Check against all blocks (Simple AABB)
        for (let i = 0; i < collisionBlocks.length; i++) {
            const block = collisionBlocks[i];
            // Optimization: Only check blocks close to player
            if (block.position.distanceToSquared(pos) < 4) {
                box.setFromObject(block);
                if (box.intersectsBox(playerBox)) return true;
            }
        }
        return false;
    }

    // --- 5. CONTROLS ---
    // A. Desktop
    const controls = new PointerLockControls(camera, document.body);
    let moveF = false, moveB = false, moveL = false, moveR = false, jump = false;
    let isInventoryOpen = false;

    document.addEventListener('click', () => {
        if(!isInventoryOpen && !renderer.xr.isPresenting) {
            controls.lock();
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('hud-desktop').style.display = 'block';
        } else if (controls.isLocked) {
            fireLaser(); // Mine!
        }
    });

    document.addEventListener('keydown', (e) => {
        switch(e.code) {
            case 'KeyW': moveF = true; break;
            case 'KeyS': moveB = true; break;
            case 'KeyA': moveL = true; break;
            case 'KeyD': moveR = true; break;
            case 'Space': jump = true; break;
            case 'KeyE': toggleInventory(); break;
        }
    });
    document.addEventListener('keyup', (e) => {
        switch(e.code) {
            case 'KeyW': moveF = false; break;
            case 'KeyS': moveB = false; break;
            case 'KeyA': moveL = false; break;
            case 'KeyD': moveR = false; break;
            case 'Space': jump = false; break;
        }
    });

    // B. VR
    const controller1 = renderer.xr.getController(0);
    controller1.addEventListener('selectstart', fireLaser); // Trigger to mine
    user.add(controller1);
    
    // Laser Visual
    const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-5)]), new THREE.LineBasicMaterial({ color: 0xff0000 }));
    controller1.add(line);

    // --- 6. GAMEPLAY LOGIC ---
    
    // Mining
    const raycaster = new THREE.Raycaster();
    const center = new THREE.Vector2(0,0);

    function fireLaser() {
        // Set Raycaster
        if (renderer.xr.isPresenting) {
            const mat = new THREE.Matrix4();
            mat.identity().extractRotation(controller1.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller1.matrixWorld);
            raycaster.ray.direction.set(0,0,-1).applyMatrix4(mat);
        } else {
            raycaster.setFromCamera(center, camera);
        }

        const intersects = raycaster.intersectObjects(visualBlocks);
        if (intersects.length > 0 && intersects[0].distance < 5) {
            const hit = intersects[0].object;
            
            // Destroy Block
            scene.remove(hit);
            collisionBlocks.splice(collisionBlocks.indexOf(hit), 1);
            visualBlocks.splice(visualBlocks.indexOf(hit), 1);
            
            // Loot
            const loot = WORD_DATA[hit.userData.type];
            if (loot && Math.random() < 0.6) {
                if(Math.random() < 0.5) {
                    player.roots.push({word: loot.roots[Math.floor(Math.random()*loot.roots.length)]});
                } else {
                    let a = loot.affixes[Math.floor(Math.random()*loot.affixes.length)];
                    player.affixes.push({val: a, type: "suf"}); // Simplified for proto
                }
                player.gems++;
                updateHud();
            }
        }
    }

    // --- 7. INVENTORY SYSTEM (Restored 2D Logic) ---
    window.toggleInventory = function() {
        const inv = document.getElementById('desktop-inv');
        isInventoryOpen = !isInventoryOpen;
        
        if (isInventoryOpen) {
            controls.unlock();
            inv.style.display = 'flex';
            renderInv();
        } else {
            controls.lock();
            inv.style.display = 'none';
        }
    };

    function updateHud() {
        document.getElementById('hud-gems').innerText = player.gems;
    }

    window.clearSlot = function(type) { forge[type] = null; renderInv(); };
    
    window.renderInv = function() {
        // Update Slots
        document.getElementById('slot-pre').innerText = forge.pre || "[Pre]";
        document.getElementById('slot-root').innerText = forge.root || "[ROOT]";
        document.getElementById('slot-suf').innerText = forge.suf || "[Suf]";

        // Render Lists
        let rList = document.getElementById('list-roots'); rList.innerHTML = "";
        player.roots.forEach(r => {
            let el = document.createElement('div'); el.className = "word-chip chip-root";
            el.innerText = r.word; el.onclick = () => { forge.root = r.word; renderInv(); };
            rList.appendChild(el);
        });

        let aList = document.getElementById('list-affixes'); aList.innerHTML = "";
        player.affixes.forEach(a => {
            let el = document.createElement('div'); el.className = "word-chip chip-suf";
            el.innerText = "-" + a.val; el.onclick = () => { forge.suf = a.val; renderInv(); };
            aList.appendChild(el);
        });
    };

    window.runForge = async function() {
        if(!forge.root) return;
        let word = ((forge.pre||"") + forge.root + (forge.suf||"")).toLowerCase();
        let msg = document.getElementById('forge-msg');
        msg.innerText = "Checking...";
        
        try {
            let res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
            if(!res.ok) throw new Error();
            let data = await res.json();
            let def = data[0].meanings[0].definitions[0].definition;
            msg.innerHTML = `<span style='color:green'>‚ú® ${word.toUpperCase()}</span>: ${def}`;
            player.gems += 10; updateHud();
            
            // Consume (Simple)
            forge = { pre:null, root:null, suf:null }; renderInv();
        } catch(e) {
            msg.innerHTML = `<span style='color:red'>‚ùå ${word} is not a word.</span>`;
        }
    };

    // --- 8. PHYSICS LOOP ---
    const clock = new THREE.Clock();
    
    renderer.setAnimationLoop(() => {
        const dt = Math.min(clock.getDelta(), 0.1); // Limit dt

        // MOVEMENT LOGIC
        if (controls.isLocked || renderer.xr.isPresenting) {
            
            // Calculate Input Vector
            let inputX = 0; let inputZ = 0;
            
            if (controls.isLocked) {
                inputZ = Number(moveF) - Number(moveB);
                inputX = Number(moveR) - Number(moveL);
            } 
            else if (renderer.xr.isPresenting) {
                const session = renderer.xr.getSession();
                if(session && session.inputSources[0] && session.inputSources[0].gamepad) {
                    // VR Joystick
                    const axes = session.inputSources[0].gamepad.axes;
                    if(Math.abs(axes[3]) > 0.1) inputZ = -axes[3];
                    if(Math.abs(axes[2]) > 0.1) inputX = -axes[2];
                }
            }

            // Apply to Velocity
            playerVelocity.x -= playerVelocity.x * 10.0 * dt;
            playerVelocity.z -= playerVelocity.z * 10.0 * dt;
            playerVelocity.y -= 25.0 * dt; // Gravity

            if (inputZ !== 0 || inputX !== 0) {
                // Get Direction relative to Camera
                const angle = user.rotation.y; // Simplified VR heading
                // For desktop, Three.js PointerLock handles direction internally, 
                // but we need manual physics for collision.
                
                // Simplified Movement for proto:
                const speed = 400.0 * dt; // Force
                playerVelocity.z += inputZ * speed * dt;
                playerVelocity.x += inputX * speed * dt;
            }

            // Tentative Move (X/Z)
            const nextPos = user.position.clone();
            nextPos.x += playerVelocity.x * dt;
            nextPos.z += playerVelocity.z * dt;
            
            if (!checkCollision(nextPos)) {
                user.position.x = nextPos.x;
                user.position.z = nextPos.z;
            } else {
                playerVelocity.x = 0; playerVelocity.z = 0;
            }

            // Tentative Move (Y)
            nextPos.copy(user.position);
            nextPos.y += playerVelocity.y * dt;

            // Feet collision check (slightly lower than center)
            const feetPos = nextPos.clone();
            feetPos.y -= 1.0; 

            if (!checkCollision(feetPos)) {
                user.position.y = nextPos.y;
            } else {
                playerVelocity.y = 0;
                // Snap to top of block?
                if (jump) playerVelocity.y = 8; // Jump impulse
            }
            
            // Kill floor
            if(user.position.y < -20) user.position.set(0, 10, 0);
        }

        renderer.render(scene, camera);
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
