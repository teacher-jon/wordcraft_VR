<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WordCraft 3D: Final Texture Edition</title>
    <style>
        /* --- CORE STYLES --- */
        body { margin: 0; overflow: hidden; font-family: 'Verdana', sans-serif; user-select: none; background: #000; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.9); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
            display: none; /* Hidden until start */
        }
        
        #hud-layer {
            position: absolute; top: 10px; left: 10px; color: white;
            text-shadow: 2px 2px 0 #000; pointer-events: none; display: none; z-index: 10;
            font-size: 18px; font-weight: bold;
        }

        /* --- YOUR ORIGINAL 2D INVENTORY --- */
        #inventory-screen {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 750px; height: 600px; 
            /* Using your BG asset */
            background: #f3e5f5 url('assets/bg.png'); background-size: cover;
            border: 6px solid #5d4037; border-radius: 12px; display: none;
            flex-direction: column; z-index: 100; color: #3e2723;
            box-shadow: 0 20px 50px rgba(0,0,0,0.9);
        }
        
        .inv-header { padding: 15px; background: rgba(255,255,255,0.95); border-bottom: 4px solid #5d4037; }
        .inv-body { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 15px; }
        .inv-footer { padding: 15px; background: rgba(255,255,255,0.95); border-top: 4px solid #5d4037; text-align:center; }

        /* Forge UI */
        .forge-area { 
            display: flex; justify-content: center; align-items: center; gap: 10px; 
            padding: 20px; background: rgba(255,255,255,0.6); border-radius: 8px; border: 2px dashed #5d4037;
        }
        .slot { 
            width: 70px; height: 70px; background: #fff; border: 3px solid #5d4037; 
            display: flex; align-items: center; justify-content: center; 
            font-weight: bold; cursor: pointer; border-radius: 8px;
            transition: 0.2s;
        }
        .slot:hover { transform: scale(1.05); border-color: #e67e22; }

        /* Chips */
        .chip { 
            display: inline-block; padding: 8px 12px; margin: 4px; border-radius: 20px; 
            background: white; border: 2px solid #5d4037; font-weight: bold; cursor: pointer;
            box-shadow: 0 2px 0 rgba(0,0,0,0.2);
        }
        .chip:active { transform: translateY(2px); box-shadow: none; }
        .chip-root { background: #c8e6c9; color: #1b5e20; }
        .chip-affix { background: #bbdefb; color: #0d47a1; }

        #forge-msg { 
            background: #fff8e1; border: 2px solid #ffca28; padding: 10px; margin-top: 10px;
            text-align: center; border-radius: 6px; font-weight: bold; color: #f57f17; min-height: 40px;
        }
        
        .btn { background: #d35400; color: white; border: none; padding: 10px 25px; font-size: 16px; font-weight: bold; border-radius: 5px; cursor: pointer; }
        .btn:hover { background: #e67e22; }
    </style>
    
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

    <div id="crosshair"></div>
    <div id="hud-layer">
        <h2>WordCraft 3D</h2>
        <p>Click to Start | WASD Move | Click Mine | 'E' Inventory</p>
        <p>üíé Gems: <span id="hud-gems">0</span></p>
    </div>

    <div id="inventory-screen">
        <div class="inv-header">
            <h2 style="margin:0; text-align:center;">The Word Forge</h2>
        </div>
        <div class="inv-body">
            <div class="forge-area">
                <div id="slot-pre" class="slot" onclick="clearSlot('pre')">[Pre]</div> +
                <div id="slot-root" class="slot" onclick="clearSlot('root')">[ROOT]</div> +
                <div id="slot-suf" class="slot" onclick="clearSlot('suf')">[Suf]</div>
                <button class="btn" style="background:#27ae60; height:70px;" onclick="runForge()">üî®</button>
            </div>
            <div id="forge-msg">Combine parts to verify with Dictionary API</div>
            
            <div style="display:flex; gap:20px;">
                <div style="flex:1; background:rgba(255,255,255,0.5); padding:10px; border-radius:8px;">
                    <h4>ROOTS</h4>
                    <div id="list-roots"></div>
                </div>
                <div style="flex:1; background:rgba(255,255,255,0.5); padding:10px; border-radius:8px;">
                    <h4>AFFIXES</h4>
                    <div id="list-affixes"></div>
                </div>
            </div>
        </div>
        <div class="inv-footer">
            <button class="btn" onclick="toggleInventory()">Close & Resume</button>
        </div>
    </div>

<script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    // --- 1. DATA & SETTINGS ---
    const CHUNK_SIZE = 16;
    const RENDER_DISTANCE = 2; 
    const WORLD_DEPTH = 10;
    
    const WORD_DATA = {
        "dirt": { roots: ["play", "help", "walk", "look"], affixes: ["s", "ed", "ing"] },
        "stone": { roots: ["struct", "ject", "form"], affixes: ["re", "un", "tion"] },
        "wood": { roots: ["grow", "leaf"], affixes: ["ness", "ful"] }
    };

    let player = { gems: 0, roots: [], affixes: [] };
    let forge = { pre: null, root: null, suf: null };

    // --- 2. SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Sky Blue
    scene.fog = new THREE.Fog(0x87CEEB, 20, 60);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
    const user = new THREE.Group();
    user.position.set(0, 20, 0); // Drop in from sky
    user.add(camera);
    scene.add(user);

    const renderer = new THREE.WebGLRenderer({ antialias: false }); // Crisp pixels
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    // --- 3. TEXTURE ATLAS LOGIC (The Fix) ---
    const textureLoader = new THREE.TextureLoader();
    let atlas = null;
    
    // Attempt to load the asset
    try {
        atlas = textureLoader.load('assets/tiles.png');
        atlas.magFilter = THREE.NearestFilter;
        atlas.minFilter = THREE.NearestFilter;
        atlas.wrapS = THREE.RepeatWrapping;
        atlas.wrapT = THREE.RepeatWrapping;
    } catch(e) { console.warn("Texture load failed"); }

    // Helper to map 1 tile from the vertical strip of 6
    function getMaterial(index) {
        if(!atlas) return new THREE.MeshLambertMaterial({ color: 0x888888 }); // Fallback
        
        const mat = new THREE.MeshLambertMaterial({ map: atlas.clone() });
        // There are 6 tiles vertically. 1/6 = 0.1666
        mat.map.repeat.set(1, 1/6);
        mat.map.offset.y = index * (1/6); 
        return mat;
    }

    // Material Map based on your 'tiles.png' layout (Bottom to Top usually)
    // Assuming: 0=Water, 1=Wood, 2=Pillar, 3=Stone, 4=Dirt, 5=Grass
    const materials = {
        grass: getMaterial(5),  // Top Block
        dirt: getMaterial(4),   // 2nd Block
        stone: getMaterial(3),  // 3rd Block
        bedrock: getMaterial(2),// 4th Block (Pillar)
        wood: getMaterial(1),   // 5th Block (Wood)
        water: getMaterial(0),  // Bottom Block
        
        // Leaf fallback (Tint the wood green or use grass)
        leaf: new THREE.MeshLambertMaterial({ color: 0x228b22 }) 
    };

    // --- 4. INFINITE TERRAIN ---
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const chunks = {};
    const activeBlocks = []; // For Raycasting
    const colliders = [];    // For Physics

    function createBlock(x, y, z, type) {
        const mesh = new THREE.Mesh(geometry, materials[type]);
        mesh.position.set(x, y, z);
        mesh.userData = { type: type, isBlock: true };
        scene.add(mesh);
        activeBlocks.push(mesh);
        colliders.push(mesh);
        return mesh;
    }

    function generateChunk(cx, cz) {
        const key = `${cx},${cz}`;
        if (chunks[key]) return;
        chunks[key] = [];

        const startX = cx * CHUNK_SIZE;
        const startZ = cz * CHUNK_SIZE;

        for (let x = startX; x < startX + CHUNK_SIZE; x++) {
            for (let z = startZ; z < startZ + CHUNK_SIZE; z++) {
                let h = Math.floor(Math.sin(x * 0.15) * 3 + Math.cos(z * 0.15) * 3);
                
                // Terrain Stack
                chunks[key].push(createBlock(x, h, z, 'grass'));
                chunks[key].push(createBlock(x, h-1, z, 'dirt'));
                chunks[key].push(createBlock(x, h-2, z, 'dirt'));
                for(let d=3; d<WORLD_DEPTH; d++) chunks[key].push(createBlock(x, h-d, z, 'stone'));
                chunks[key].push(createBlock(x, h-WORLD_DEPTH, z, 'bedrock'));

                // Trees
                if (Math.random() < 0.03) {
                    let th = h + 1;
                    chunks[key].push(createBlock(x, th, z, 'wood'));
                    chunks[key].push(createBlock(x, th+1, z, 'wood'));
                    chunks[key].push(createBlock(x, th+2, z, 'leaf'));
                    chunks[key].push(createBlock(x+1, th+1, z, 'leaf'));
                    chunks[key].push(createBlock(x-1, th+1, z, 'leaf'));
                    chunks[key].push(createBlock(x, th+1, z+1, 'leaf'));
                    chunks[key].push(createBlock(x, th+1, z-1, 'leaf'));
                }
            }
        }
    }

    function updateWorld() {
        const px = user.position.x;
        const pz = user.position.z;
        const cx = Math.floor(px / CHUNK_SIZE);
        const cz = Math.floor(pz / CHUNK_SIZE);

        for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
            for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                generateChunk(cx + x, cz + z);
            }
        }
        
        // Simple Cleanup
        for (const key in chunks) {
            const [kcx, kcz] = key.split(',').map(Number);
            if (Math.abs(kcx - cx) > RENDER_DISTANCE + 1 || Math.abs(kcz - cz) > RENDER_DISTANCE + 1) {
                chunks[key].forEach(mesh => {
                    scene.remove(mesh);
                    const ai = activeBlocks.indexOf(mesh); if(ai>-1) activeBlocks.splice(ai,1);
                    const ci = colliders.indexOf(mesh); if(ci>-1) colliders.splice(ci,1);
                });
                delete chunks[key];
            }
        }
    }

    // --- 5. CONTROLS & PHYSICS ---
    const controls = new PointerLockControls(camera, document.body);
    let moveF=false, moveB=false, moveL=false, moveR=false;
    let velocity = new THREE.Vector3();
    let canJump = false;
    let isInventoryOpen = false;

    // Keys
    document.addEventListener('keydown', (e) => {
        switch(e.code) {
            case 'KeyW': moveF = true; break;
            case 'KeyS': moveB = true; break;
            case 'KeyA': moveL = true; break;
            case 'KeyD': moveR = true; break;
            case 'Space': if(canJump) velocity.y = 12; canJump = false; break;
            case 'KeyE': toggleInventory(); break;
        }
    });
    document.addEventListener('keyup', (e) => {
        switch(e.code) {
            case 'KeyW': moveF = false; break;
            case 'KeyS': moveB = false; break;
            case 'KeyA': moveL = false; break;
            case 'KeyD': moveR = false; break;
        }
    });

    // Mouse Interaction
    document.addEventListener('click', () => {
        if(!isInventoryOpen) {
            if(!controls.isLocked) {
                controls.lock();
                document.getElementById('crosshair').style.display = 'block';
                document.getElementById('hud-layer').style.display = 'block';
            } else {
                mineBlock();
            }
        }
    });

    // Mining Raycaster
    const raycaster = new THREE.Raycaster();
    const center = new THREE.Vector2(0,0);

    function mineBlock() {
        raycaster.setFromCamera(center, camera);
        const intersects = raycaster.intersectObjects(activeBlocks);
        
        if (intersects.length > 0 && intersects[0].distance < 6) {
            const hit = intersects[0].object;
            const type = hit.userData.type;
            
            if(type === 'bedrock') return; // Cannot mine

            scene.remove(hit);
            activeBlocks.splice(activeBlocks.indexOf(hit), 1);
            colliders.splice(colliders.indexOf(hit), 1);
            
            // Loot Logic
            if(WORD_DATA[type] && Math.random() < 0.7) {
                const loot = WORD_DATA[type];
                if(Math.random() < 0.5) {
                    let w = loot.roots[Math.floor(Math.random()*loot.roots.length)];
                    player.roots.push(w);
                } else {
                    let a = loot.affixes[Math.floor(Math.random()*loot.affixes.length)];
                    player.affixes.push({val:a, type:"suf"});
                }
                player.gems++;
                updateHud();
            }
        }
    }

    // Collision Logic
    const playerBox = new THREE.Box3();
    const playerSize = new THREE.Vector3(0.5, 1.8, 0.5);
    const wallBox = new THREE.Box3();

    function checkCollision(pos) {
        playerBox.setFromCenterAndSize(pos, playerSize);
        for(let mesh of colliders) {
            if(mesh.position.distanceToSquared(pos) < 6) { // Optimization
                wallBox.setFromObject(mesh);
                if(wallBox.intersectsBox(playerBox)) return true;
            }
        }
        return false;
    }

    // --- 6. GAME LOOP ---
    const clock = new THREE.Clock();
    updateWorld(); // Init

    function animate() {
        requestAnimationFrame(animate);
        const dt = Math.min(clock.getDelta(), 0.1);

        if(controls.isLocked) {
            // Friction
            velocity.x -= velocity.x * 10.0 * dt;
            velocity.z -= velocity.z * 10.0 * dt;
            velocity.y -= 30.0 * dt; // Gravity

            // WASD Direction relative to Camera
            const direction = new THREE.Vector3();
            direction.z = Number(moveF) - Number(moveB);
            direction.x = Number(moveR) - Number(moveL);
            direction.normalize();

            if (moveF || moveB) velocity.z -= direction.z * 150.0 * dt;
            if (moveL || moveR) velocity.x -= direction.x * 150.0 * dt;

            // Apply Move (X/Z)
            controls.moveRight(-velocity.x * dt);
            controls.moveForward(-velocity.z * dt);
            
            // Apply Gravity (Y)
            user.position.y += velocity.y * dt;

            // Simple Floor Check
            // We cast a ray down from feet
            const footPos = user.position.clone();
            footPos.y -= 1.6;
            
            // Are we inside a block?
            if(checkCollision(footPos)) {
                velocity.y = Math.max(0, velocity.y);
                user.position.y = Math.ceil(footPos.y) + 1.6;
                canJump = true;
            }

            // Infinite Gen
            updateWorld();
        }
        renderer.render(scene, camera);
    }
    animate();

    // --- 7. INVENTORY SYSTEM ---
    window.toggleInventory = function() {
        isInventoryOpen = !isInventoryOpen;
        const el = document.getElementById('inventory-screen');
        if(isInventoryOpen) {
            controls.unlock();
            el.style.display = 'flex';
            renderInv();
        } else {
            controls.lock();
            el.style.display = 'none';
        }
    };

    function updateHud() {
        document.getElementById('hud-gems').innerText = player.gems;
    }

    window.renderInv = function() {
        updateHud();
        document.getElementById('slot-pre').innerText = forge.pre || "[Pre]";
        document.getElementById('slot-root').innerText = forge.root || "[ROOT]";
        document.getElementById('slot-suf').innerText = forge.suf || "[Suf]";

        let rList = document.getElementById('list-roots'); rList.innerHTML = "";
        player.roots.forEach(r => {
            let el = document.createElement('div'); el.className = "chip chip-root";
            el.innerText = r; el.onclick = () => { forge.root = r; renderInv(); };
            rList.appendChild(el);
        });

        let aList = document.getElementById('list-affixes'); aList.innerHTML = "";
        player.affixes.forEach(a => {
            let el = document.createElement('div'); el.className = "chip chip-affix";
            el.innerText = "-" + a.val; el.onclick = () => { forge.suf = a.val; renderInv(); };
            aList.appendChild(el);
        });
    };

    window.clearSlot = (t) => { forge[t] = null; renderInv(); };

    window.runForge = async function() {
        if(!forge.root) return;
        let word = ((forge.pre||"") + forge.root + (forge.suf||"")).toLowerCase();
        let msg = document.getElementById('forge-msg');
        msg.innerText = "Checking Dictionary...";
        
        try {
            let res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
            if(!res.ok) throw new Error();
            let data = await res.json();
            msg.innerHTML = `<span style='color:green'>‚ú® ${word.toUpperCase()}</span>: ${data[0].meanings[0].definitions[0].definition}`;
            player.gems += 15; updateHud();
            forge = {pre:null, root:null, suf:null}; renderInv();
        } catch(e) {
            msg.innerHTML = `<span style='color:red'>‚ùå ${word} is not a valid word.</span>`;
        }
    };

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
