<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WordCraft 3D: Ultimate Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; font-weight: bold; background: rgba(0,0,0,0.8); padding: 20px;
        }

        #desktop-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #crosshair {
            width: 20px; height: 20px; border: 2px solid rgba(255,255,255,0.8);
            border-radius: 50%; background: rgba(255,255,255,0.2);
        }
        #hud-info {
            position: absolute; top: 20px; left: 20px; color: white; text-shadow: 2px 2px 0 #000;
            font-size: 20px; font-weight: bold;
        }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

<div id="loading">PROCESSING TEXTURES...</div>

<div id="desktop-ui">
    <div id="crosshair"></div>
    <div id="hud-info">ðŸ’Ž: <span id="ui-gems">0</span> | HP: <span id="ui-hp">3</span></div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    // --- 1. CONFIG ---
    const STATE = { hp: 3, gems: 0, roots: [], affixes: [], inventoryOpen: false, forge: { pre: null, root: null, suf: null }, msg: "" };
    const LOOT = {
        "dirt": { roots: ["play", "help", "walk"], affixes: ["ed", "ing"] },
        "stone": { roots: ["struct", "ject"], affixes: ["re", "un"] },
        "wood": { roots: ["grow", "leaf"], affixes: ["ness", "ful"] }
    };

    // --- 2. TEXTURE PROCESSOR (The Fixer) ---
    // This removes white pixels and splits the image into individual textures
    function processImage(imgUrl, rows, cols) {
        return new Promise((resolve) => {
            const img = new Image();
            img.src = imgUrl;
            img.onload = () => {
                const textures = [];
                const w = img.width / cols;
                const h = img.height / rows;

                for(let r=0; r<rows; r++) {
                    for(let c=0; c<cols; c++) {
                        const canvas = document.createElement('canvas');
                        canvas.width = 64; canvas.height = 64;
                        const ctx = canvas.getContext('2d');
                        
                        // Draw slice
                        ctx.drawImage(img, c*w, r*h, w, h, 0, 0, 64, 64);
                        
                        // REMOVE WHITE BACKGROUND
                        const imgData = ctx.getImageData(0,0,64,64);
                        const data = imgData.data;
                        for(let i=0; i<data.length; i+=4) {
                            // If pixel is very bright (white), make it transparent
                            if(data[i]>240 && data[i+1]>240 && data[i+2]>240) {
                                data[i+3] = 0; // Alpha = 0
                            }
                        }
                        ctx.putImageData(imgData, 0, 0);

                        const tex = new THREE.CanvasTexture(canvas);
                        tex.magFilter = THREE.NearestFilter;
                        tex.minFilter = THREE.NearestFilter;
                        tex.colorSpace = THREE.SRGBColorSpace;
                        textures.push(tex);
                    }
                }
                resolve(textures);
            };
        });
    }

    // --- 3. ASSET LOADING ---
    const MATS = {};
    let matBat, matSlime;

    async function loadAssets() {
        // Process Tiles (1 Column, 5 Rows)
        const tileTexs = await processImage('assets/tiles.png', 5, 1);
        MATS['grass'] = new THREE.MeshLambertMaterial({ map: tileTexs[0] });
        MATS['dirt']  = new THREE.MeshLambertMaterial({ map: tileTexs[1] });
        MATS['stone'] = new THREE.MeshLambertMaterial({ map: tileTexs[2] });
        MATS['wood']  = new THREE.MeshLambertMaterial({ map: tileTexs[3] });
        MATS['leaf']  = new THREE.MeshLambertMaterial({ map: tileTexs[4], transparent: true, opacity: 0.9, side: THREE.DoubleSide });

        // Process Chars (3 Columns, 3 Rows)
        const charTexs = await processImage('assets/chars.png', 3, 3);
        // Bat is usually at index 4 (Row 1, Col 1), Slime at index 8 (Row 2, Col 2) - Adjust based on your sheet
        // Based on typical spritesheet logic:
        matBat = new THREE.MeshBasicMaterial({ map: charTexs[4], transparent: true, side: THREE.DoubleSide }); 
        matSlime = new THREE.MeshBasicMaterial({ map: charTexs[8], transparent: true, side: THREE.DoubleSide });

        document.getElementById('loading').style.display = 'none';
        initGame();
    }

    // --- 4. SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 10, 40);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
    const dolly = new THREE.Group();
    dolly.position.set(0, 5, 0);
    dolly.add(camera);
    scene.add(dolly);

    const renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);
    document.body.appendChild(VRButton.createButton(renderer));

    const light = new THREE.DirectionalLight(0xffffff, 1.0);
    light.position.set(10, 20, 10);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));

    // --- 5. WORLD GEN ---
    const activeBlocks = [];
    const blockGeo = new THREE.BoxGeometry(1, 1, 1);

    function createBlock(x, y, z, type) {
        const mesh = new THREE.Mesh(blockGeo, MATS[type] || MATS['dirt']);
        mesh.position.set(x, y, z);
        mesh.userData = { type: type };
        scene.add(mesh);
        activeBlocks.push(mesh);
    }

    function initGame() {
        // Generate Terrain
        for(let x=-8; x<8; x++) {
            for(let z=-8; z<8; z++) {
                let h = Math.floor(Math.sin(x*0.2)*2 + Math.cos(z*0.2)*2);
                createBlock(x, h, z, 'grass');
                createBlock(x, h-1, z, 'dirt');
                for(let d=2; d<5; d++) createBlock(x, h-d, z, 'stone');
                
                if(Math.random() < 0.05) {
                    createBlock(x, h+1, z, 'wood');
                    createBlock(x, h+2, z, 'wood');
                    createBlock(x, h+3, z, 'leaf');
                    createBlock(x+1, h+2, z, 'leaf');
                    createBlock(x-1, h+2, z, 'leaf');
                    createBlock(x, h+2, z+1, 'leaf');
                    createBlock(x, h+2, z-1, 'leaf');
                }
            }
        }
        
        // Spawn Enemies loop
        setInterval(spawnEnemy, 3000);
    }

    // --- 6. ENEMIES ---
    const enemies = [];
    const enemyGeo = new THREE.BoxGeometry(0.7, 0.7, 0.7);

    function spawnEnemy() {
        if(enemies.length >= 5) return;
        const angle = Math.random() * Math.PI * 2;
        const dist = 5 + Math.random() * 5;
        const x = dolly.position.x + Math.cos(angle) * dist;
        const z = dolly.position.z + Math.sin(angle) * dist;
        
        const type = Math.random()>0.5 ? 'bat' : 'slime';
        const mat = type === 'bat' ? matBat : matSlime;

        const e = new THREE.Mesh(enemyGeo, mat);
        e.position.set(x, 10, z);
        e.userData = { dy: 0 };
        scene.add(e);
        enemies.push(e);
    }

    function updateEnemies(dt) {
        enemies.forEach((e, i) => {
            const dir = new THREE.Vector3().subVectors(dolly.position, e.position).normalize();
            e.position.add(dir.multiplyScalar(2 * dt));
            e.userData.dy += dt * 5;
            e.position.y += Math.sin(e.userData.dy) * 0.01;
            e.lookAt(dolly.position);

            if(e.position.distanceTo(dolly.position) < 1.0) {
                STATE.hp--;
                document.getElementById('ui-hp').innerText = STATE.hp;
                scene.remove(e);
                enemies.splice(i, 1);
                scene.background = new THREE.Color(0xff0000);
                setTimeout(()=>scene.background=new THREE.Color(0x87CEEB), 100);
            }
        });
    }

    // --- 7. CONTROLS ---
    const controls = new PointerLockControls(camera, document.body);
    const keys = { w:false, a:false, s:false, d:false };
    
    document.addEventListener('keydown', e => {
        if(e.key==='w') keys.w=true; if(e.key==='a') keys.a=true; 
        if(e.key==='s') keys.s=true; if(e.key==='d') keys.d=true;
    });
    document.addEventListener('keyup', e => {
        if(e.key==='w') keys.w=false; if(e.key==='a') keys.a=false; 
        if(e.key==='s') keys.s=false; if(e.key==='d') keys.d=false;
    });
    
    // RAYCASTING (Mining)
    const raycaster = new THREE.Raycaster();
    
    document.addEventListener('click', () => {
        if(!renderer.xr.isPresenting) {
            if(!controls.isLocked) controls.lock();
            else attemptMine();
        }
    });

    function attemptMine() {
        // Raycast from Camera Center
        raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
        const hits = raycaster.intersectObjects(activeBlocks);
        
        if(hits.length > 0 && hits[0].distance < 6) {
            const hit = hits[0].object;
            
            // Effect: Flash block
            hit.material.color.setHex(0xff0000);
            
            setTimeout(() => {
                scene.remove(hit);
                activeBlocks.splice(activeBlocks.indexOf(hit), 1);
                
                // Loot Logic
                const t = hit.userData.type;
                if(LOOT[t]) {
                    STATE.gems++;
                    document.getElementById('ui-gems').innerText = STATE.gems;
                }
            }, 100);
        }
    }

    // VR CONTROLLERS
    const controller1 = renderer.xr.getController(0);
    controller1.addEventListener('selectstart', attemptMineVR); // Trigger
    dolly.add(controller1);

    function attemptMineVR(e) {
        const c = e.target;
        const mat = new THREE.Matrix4().extractRotation(c.matrixWorld);
        const dir = new THREE.Vector3(0,0,-1).applyMatrix4(mat);
        const origin = new THREE.Vector3().setFromMatrixPosition(c.matrixWorld);
        
        raycaster.set(origin, dir);
        const hits = raycaster.intersectObjects(activeBlocks);
        if(hits.length > 0 && hits[0].distance < 6) {
             const hit = hits[0].object;
             scene.remove(hit);
             activeBlocks.splice(activeBlocks.indexOf(hit), 1);
             STATE.gems++;
             document.getElementById('ui-gems').innerText = STATE.gems;
        }
    }

    // --- 8. LOOP ---
    const clock = new THREE.Clock();
    
    renderer.setAnimationLoop(() => {
        const dt = clock.getDelta();
        updateEnemies(dt);

        // Movement
        if(!renderer.xr.isPresenting && controls.isLocked) {
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir); dir.y=0; dir.normalize();
            const side = new THREE.Vector3().crossVectors(camera.up, dir).normalize();
            const spd = 5 * dt;
            if(keys.w) dolly.position.add(dir.multiplyScalar(spd));
            if(keys.s) dolly.position.add(dir.multiplyScalar(-spd));
            if(keys.a) dolly.position.add(side.multiplyScalar(spd));
            if(keys.d) dolly.position.add(side.multiplyScalar(-spd));
        }

        renderer.render(scene, camera);
    });

    // START
    loadAssets();

</script>
</body>
</html>
