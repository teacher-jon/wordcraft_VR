<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WordCraft 3D: Solid Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Courier New', monospace; }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; font-weight: bold; background: rgba(0,0,0,0.8); padding: 20px;
            pointer-events: none; z-index: 999;
        }

        #desktop-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #crosshair {
            width: 20px; height: 20px; border: 2px solid rgba(255,255,255,0.8);
            border-radius: 50%; background: rgba(255,255,255,0.2);
        }
        #hud-info {
            position: absolute; top: 20px; left: 20px; color: white; text-shadow: 2px 2px 0 #000;
            font-size: 20px; font-weight: bold;
        }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

<div id="loading">BUILDING WORLD...</div>

<div id="desktop-ui">
    <div id="crosshair"></div>
    <div id="hud-info">ðŸ’Ž: <span id="ui-gems">0</span> | HP: <span id="ui-hp">3</span></div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    const STATE = { hp: 3, gems: 0, msg: "" };

    // --- 1. ASSET PROCESSOR ---
    // This cuts the images but ensures MATERIALS ARE SOLID (Fixes Glass Glitch)
    function cutTexture(image, row, totalRows) {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const h = image.height / totalRows;
        ctx.drawImage(image, 0, row * h, image.width, h, 0, 0, 64, 64);
        
        const tex = new THREE.CanvasTexture(canvas);
        tex.magFilter = THREE.NearestFilter; // Pixel Art Look
        tex.colorSpace = THREE.SRGBColorSpace;
        return tex;
    }

    function cutSprite(image, col, row) {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const w = image.width / 3;
        const h = image.height / 3;
        ctx.drawImage(image, col * w, row * h, w, h, 0, 0, 64, 64);
        
        const tex = new THREE.CanvasTexture(canvas);
        tex.magFilter = THREE.NearestFilter;
        tex.colorSpace = THREE.SRGBColorSpace;
        return tex;
    }

    // --- 2. LOAD & INIT ---
    const MATS = {};
    const ENEMY_MATS = {};

    const imgLoader = new THREE.ImageLoader();
    let assetsLoaded = 0;

    function checkLoad() {
        assetsLoaded++;
        if(assetsLoaded === 2) {
            document.getElementById('loading').style.display = 'none';
            init();
        }
    }

    // Load Tiles
    imgLoader.load('assets/tiles.png', (img) => {
        // IMPORTANT: transparent: false for solid blocks fixes the "Glass World"
        MATS['grass'] = new THREE.MeshLambertMaterial({ map: cutTexture(img, 0, 5) });
        MATS['dirt']  = new THREE.MeshLambertMaterial({ map: cutTexture(img, 1, 5) });
        MATS['stone'] = new THREE.MeshLambertMaterial({ map: cutTexture(img, 2, 5) });
        MATS['wood']  = new THREE.MeshLambertMaterial({ map: cutTexture(img, 3, 5) });
        // Leaves stay transparent
        MATS['leaf']  = new THREE.MeshLambertMaterial({ map: cutTexture(img, 4, 5), transparent: true, opacity: 1.0, alphaTest: 0.5 });
        checkLoad();
    });

    // Load Chars
    imgLoader.load('assets/chars.png', (img) => {
        // We create materials for 3D Cubes
        ENEMY_MATS['bat'] = new THREE.MeshBasicMaterial({ map: cutSprite(img, 1, 1), transparent: true, side: THREE.DoubleSide }); 
        ENEMY_MATS['slime'] = new THREE.MeshBasicMaterial({ map: cutSprite(img, 2, 2), transparent: true, side: THREE.DoubleSide });
        checkLoad();
    });

    // --- 3. SCENE ---
    let scene, camera, renderer, dolly;
    const activeBlocks = [];
    const enemies = [];

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
        dolly = new THREE.Group();
        dolly.position.set(0, 5, 0);
        dolly.add(camera);
        scene.add(dolly);

        renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        // Lights
        const sun = new THREE.DirectionalLight(0xffffff, 1.0);
        sun.position.set(20, 50, 20);
        scene.add(sun);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));

        // Generate Terrain
        for(let x=-8; x<8; x++) {
            for(let z=-8; z<8; z++) {
                let h = Math.floor(Math.sin(x*0.2)*2 + Math.cos(z*0.2)*2);
                createBlock(x, h, z, 'grass');
                createBlock(x, h-1, z, 'dirt');
                for(let d=2; d<4; d++) createBlock(x, h-d, z, 'stone');
                
                if(Math.random()<0.05) { // Tree
                     createBlock(x, h+1, z, 'wood');
                     createBlock(x, h+2, z, 'wood');
                     createBlock(x, h+3, z, 'leaf');
                     createBlock(x+1, h+2, z, 'leaf');
                     createBlock(x-1, h+2, z, 'leaf');
                     createBlock(x, h+2, z+1, 'leaf');
                     createBlock(x, h+2, z-1, 'leaf');
                }
            }
        }

        // Start Loop
        setInterval(spawnEnemy, 2000);
        setupControls();
        renderer.setAnimationLoop(render);
    }

    const boxGeo = new THREE.BoxGeometry(1,1,1);
    
    function createBlock(x, y, z, type) {
        const mat = MATS[type] || MATS['dirt'];
        const mesh = new THREE.Mesh(boxGeo, mat);
        mesh.position.set(x, y, z);
        mesh.userData = { type: type, isBlock: true };
        scene.add(mesh);
        activeBlocks.push(mesh);
    }

    // --- 4. CUBE ENEMIES (Minecraft Style) ---
    const enemyGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8); // Cube Shape

    function spawnEnemy() {
        if(enemies.length > 6) return;
        const type = Math.random() > 0.5 ? 'bat' : 'slime';
        if(!ENEMY_MATS[type]) return;

        const enemy = new THREE.Mesh(enemyGeo, ENEMY_MATS[type]);
        
        const angle = Math.random() * Math.PI * 2;
        const dist = 6 + Math.random() * 4;
        enemy.position.set(
            dolly.position.x + Math.cos(angle) * dist,
            10, // Drop from sky
            dolly.position.z + Math.sin(angle) * dist
        );
        
        enemy.userData = { dy: 0 };
        scene.add(enemy);
        enemies.push(enemy);
    }

    // --- 5. LOOP ---
    const clock = new THREE.Clock();

    function render() {
        const dt = clock.getDelta();

        enemies.forEach((e, i) => {
            // Move
            const dir = new THREE.Vector3().subVectors(dolly.position, e.position).normalize();
            e.position.add(dir.multiplyScalar(2 * dt));
            
            // Bob up and down
            e.userData.dy += dt * 5;
            e.position.y += Math.sin(e.userData.dy) * 0.02;
            
            // Face Player
            e.lookAt(dolly.position);

            // Hit Logic
            if(e.position.distanceTo(dolly.position) < 1.0) {
                STATE.hp--;
                document.getElementById('ui-hp').innerText = STATE.hp;
                scene.remove(e);
                enemies.splice(i, 1);
                scene.background = new THREE.Color(0xff0000);
                setTimeout(()=>scene.background = new THREE.Color(0x87CEEB), 100);
            }
        });

        // Desktop Walk
        if(!renderer.xr.isPresenting && controls.isLocked) {
            const d = new THREE.Vector3();
            camera.getWorldDirection(d); d.y=0; d.normalize();
            const s = new THREE.Vector3().crossVectors(camera.up, d).normalize();
            const spd = 5 * dt;
            if(keys.w) dolly.position.add(d.multiplyScalar(spd));
            if(keys.s) dolly.position.add(d.multiplyScalar(-spd));
            if(keys.a) dolly.position.add(s.multiplyScalar(spd));
            if(keys.d) dolly.position.add(s.multiplyScalar(-spd));
        }

        renderer.render(scene, camera);
    }

    // --- 6. CONTROLS ---
    let controls;
    const keys = { w:false, a:false, s:false, d:false };
    const raycaster = new THREE.Raycaster();

    function setupControls() {
        controls = new PointerLockControls(camera, document.body);
        document.addEventListener('keydown', e => { if(keys.hasOwnProperty(e.key)) keys[e.key] = true; });
        document.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.key)) keys[e.key] = false; });
        
        document.addEventListener('mousedown', () => {
            if(!renderer.xr.isPresenting) {
                if(!controls.isLocked) controls.lock();
                else mine();
            }
        });

        const c1 = renderer.xr.getController(0);
        c1.addEventListener('selectstart', mineVR);
        dolly.add(c1);
    }

    function mine() {
        raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
        checkHit(raycaster);
    }

    function mineVR(e) {
        const c = e.target;
        const mat = new THREE.Matrix4().extractRotation(c.matrixWorld);
        raycaster.set(c.position, new THREE.Vector3(0,0,-1).applyMatrix4(mat));
        checkHit(raycaster);
    }

    function checkHit(ray) {
        const hits = ray.intersectObjects(activeBlocks);
        if(hits.length > 0 && hits[0].distance < 6) {
            const hit = hits[0].object;
            scene.remove(hit);
            activeBlocks.splice(activeBlocks.indexOf(hit), 1);
            STATE.gems++;
            document.getElementById('ui-gems').innerText = STATE.gems;
        }
    }

</script>
</body>
</html>
