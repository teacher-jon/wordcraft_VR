<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WordCraft: Voxel Builder</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Courier New', monospace; }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; font-weight: bold; background: rgba(0,0,0,0.8); padding: 20px;
            pointer-events: none; z-index: 999;
        }

        #desktop-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #crosshair {
            width: 20px; height: 20px; border: 2px solid rgba(255,255,255,0.8);
            border-radius: 50%; background: rgba(255,255,255,0.2);
        }
        #hud-info {
            position: absolute; top: 20px; left: 20px; color: white; text-shadow: 2px 2px 0 #000;
            font-size: 20px; font-weight: bold;
        }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

<div id="loading">BUILDING 3D VOXELS...</div>

<div id="desktop-ui">
    <div id="crosshair"></div>
    <div id="hud-info">ðŸ’Ž: <span id="ui-gems">0</span> | HP: <span id="ui-hp">3</span></div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    // --- 1. CONFIG ---
    const STATE = { hp: 3, gems: 0, msg: "" };
    const LOOT = { "dirt": { roots: ["play"], affixes: ["ed"] }, "stone": { roots: ["struct"], affixes: ["re"] } };

    // --- 2. VOXEL BUILDER ENGINE ---
    // This turns a flat image into a group of 3D cubes
    function buildVoxelModel(image, col, row, totalCols, totalRows) {
        const size = 32; // Resolution
        const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        // Draw the specific sprite frame
        const sw = image.width / totalCols;
        const sh = image.height / totalRows;
        ctx.drawImage(image, col * sw, row * sh, sw, sh, 0, 0, size, size);
        
        const imgData = ctx.getImageData(0, 0, size, size).data;
        const group = new THREE.Group();
        
        // Material for the voxels
        const voxelGeo = new THREE.BoxGeometry(1, 1, 1);
        
        for(let y=0; y<size; y++) {
            for(let x=0; x<size; x++) {
                const i = (y * size + x) * 4;
                const r = imgData[i];
                const g = imgData[i+1];
                const b = imgData[i+2];
                const a = imgData[i+3];

                // If pixel is visible and NOT white background
                if(a > 0 && !(r>240 && g>240 && b>240)) {
                    const mat = new THREE.MeshBasicMaterial({ color: `rgb(${r},${g},${b})` });
                    const voxel = new THREE.Mesh(voxelGeo, mat);
                    
                    // Position voxel (Center is 0,0)
                    voxel.position.set(x - size/2, (size - y) - size/2, 0);
                    group.add(voxel);
                }
            }
        }
        
        // Scale down the giant group of cubes to look like a character
        const scale = 0.03;
        group.scale.set(scale, scale, scale);
        return group;
    }

    // --- 3. ASSET LOADING ---
    const MATS = {};
    const MODELS = {};

    async function loadAssets() {
        const loader = new THREE.TextureLoader();
        const rand = "?v=" + Math.random(); // Force cache refresh

        // 1. Load TILES (Solid Blocks)
        const tiles = await loader.loadAsync('assets/tiles.png' + rand);
        tiles.magFilter = THREE.NearestFilter;
        tiles.colorSpace = THREE.SRGBColorSpace;

        function getMat(index, transparent=false) {
            const tex = tiles.clone();
            tex.magFilter = THREE.NearestFilter;
            tex.repeat.set(1, 0.2);
            tex.offset.y = 1 - ((index + 1) * 0.2);
            return new THREE.MeshLambertMaterial({ 
                map: tex, 
                transparent: transparent, // IMPORTANT: False for dirt/stone
                opacity: 1,
                alphaTest: transparent ? 0.5 : 0 
            });
        }

        MATS['grass'] = getMat(0, false);
        MATS['dirt']  = getMat(1, false);
        MATS['stone'] = getMat(2, false);
        MATS['wood']  = getMat(3, false);
        MATS['leaf']  = getMat(4, true); // Leaves need transparency

        // 2. Load CHARS (Voxelize)
        const charImg = new Image();
        charImg.src = 'assets/chars.png' + rand;
        charImg.crossOrigin = "Anonymous";
        charImg.onload = () => {
            // Build the 3D models
            MODELS['bat'] = buildVoxelModel(charImg, 1, 1, 3, 3); // Center of grid
            MODELS['slime'] = buildVoxelModel(charImg, 2, 2, 3, 3); // Bottom Right
            
            document.getElementById('loading').style.display = 'none';
            initGame();
        };
    }

    // --- 4. SCENE ---
    let scene, camera, renderer, dolly;
    const activeBlocks = [];
    const enemies = [];

    function initGame() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, 40);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
        dolly = new THREE.Group();
        dolly.position.set(0, 5, 0);
        dolly.add(camera);
        scene.add(dolly);

        renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        // Light
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(20, 50, 20);
        scene.add(sun);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));

        // World Gen
        const blockGeo = new THREE.BoxGeometry(1, 1, 1);
        
        function createBlock(x, y, z, type) {
            const mesh = new THREE.Mesh(blockGeo, MATS[type]);
            mesh.position.set(x, y, z);
            mesh.userData = { type: type, isBlock: true };
            scene.add(mesh);
            activeBlocks.push(mesh);
        }

        for(let x=-8; x<8; x++) {
            for(let z=-8; z<8; z++) {
                let h = Math.floor(Math.sin(x*0.2)*2 + Math.cos(z*0.2)*2);
                createBlock(x, h, z, 'grass');
                createBlock(x, h-1, z, 'dirt');
                for(let d=2; d<5; d++) createBlock(x, h-d, z, 'stone');
                if(Math.random()<0.05) {
                    createBlock(x, h+1, z, 'wood');
                    createBlock(x, h+2, z, 'wood');
                    createBlock(x, h+3, z, 'leaf');
                }
            }
        }

        // Spawn Loop
        setInterval(spawnEnemy, 3000);
        
        setupControls();
        renderer.setAnimationLoop(render);
    }

    // --- 5. ENEMIES ---
    function spawnEnemy() {
        if(enemies.length > 5) return;
        const type = Math.random() > 0.5 ? 'bat' : 'slime';
        if(!MODELS[type]) return;

        // Clone the voxel model
        const enemy = MODELS[type].clone();
        
        const angle = Math.random() * Math.PI * 2;
        const dist = 6 + Math.random() * 4;
        enemy.position.set(dolly.position.x + Math.cos(angle)*dist, 10, dolly.position.z + Math.sin(angle)*dist);
        
        enemy.userData = { dy: 0 };
        scene.add(enemy);
        enemies.push(enemy);
    }

    // --- 6. RENDER LOOP ---
    const clock = new THREE.Clock();

    function render() {
        const dt = clock.getDelta();

        enemies.forEach((e, i) => {
            const dir = new THREE.Vector3().subVectors(dolly.position, e.position).normalize();
            e.position.add(dir.multiplyScalar(2 * dt));
            e.userData.dy += dt * 5;
            e.position.y += Math.sin(e.userData.dy) * 0.02;
            e.lookAt(dolly.position);

            if(e.position.distanceTo(dolly.position) < 1.0) {
                STATE.hp--;
                document.getElementById('ui-hp').innerText = STATE.hp;
                scene.remove(e);
                enemies.splice(i, 1);
                scene.background = new THREE.Color(0xff0000);
                setTimeout(()=>scene.background=new THREE.Color(0x87CEEB), 100);
            }
        });

        // Desktop Move
        if(!renderer.xr.isPresenting && controls.isLocked) {
            const d = new THREE.Vector3();
            camera.getWorldDirection(d); d.y=0; d.normalize();
            const s = new THREE.Vector3().crossVectors(camera.up, d).normalize();
            const spd = 5 * dt;
            if(keys.w) dolly.position.add(d.multiplyScalar(spd));
            if(keys.s) dolly.position.add(d.multiplyScalar(-spd));
            if(keys.a) dolly.position.add(s.multiplyScalar(spd));
            if(keys.d) dolly.position.add(s.multiplyScalar(-spd));
        }

        renderer.render(scene, camera);
    }

    // --- 7. CONTROLS ---
    let controls;
    const keys = { w:false, a:false, s:false, d:false };
    const raycaster = new THREE.Raycaster();

    function setupControls() {
        controls = new PointerLockControls(camera, document.body);
        document.addEventListener('keydown', e => { if(keys.hasOwnProperty(e.key)) keys[e.key] = true; });
        document.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.key)) keys[e.key] = false; });
        document.addEventListener('mousedown', () => {
            if(!renderer.xr.isPresenting) {
                if(!controls.isLocked) controls.lock();
                else mine();
            }
        });
        
        // VR
        const c1 = renderer.xr.getController(0);
        c1.addEventListener('selectstart', mineVR);
        dolly.add(c1);
    }

    function mine() {
        raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
        checkHit(raycaster);
    }
    function mineVR(e) {
        const c = e.target;
        const mat = new THREE.Matrix4().extractRotation(c.matrixWorld);
        raycaster.set(c.position, new THREE.Vector3(0,0,-1).applyMatrix4(mat));
        checkHit(raycaster);
    }

    function checkHit(ray) {
        const hits = ray.intersectObjects(activeBlocks);
        if(hits.length > 0 && hits[0].distance < 6) {
            const hit = hits[0].object;
            scene.remove(hit);
            activeBlocks.splice(activeBlocks.indexOf(hit), 1);
            STATE.gems++;
            document.getElementById('ui-gems').innerText = STATE.gems;
        }
    }

    loadAssets();
</script>
</body>
</html>
